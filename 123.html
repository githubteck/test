<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TV Channels Data</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            background-color: #f4f4f4;
        }
        .entry {
            margin-bottom: 20px;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
            background: #fff;
        }
        pre {
            background-color: #efefef;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }
        #download-button {
            margin: 20px 0;
            padding: 10px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        #download-button:hover {
            background-color: #0056b3;
        }
    </style>
</head>
<body>

<h1>TV Channels</h1>
<div id="channel-list"></div>
<button id="download-button" onclick="downloadM3U8()">Download as M3U8</button>

<script>
    let channelData = ''; // To hold formatted channel data for downloading

    async function fetchTVData() {
        try {
            const response = await fetch('https://raw.githubusercontent.com/aseanic/aseanic.github.io/refs/heads/main/tv');
            const textData = await response.text();
            const channels = parseChannels(textData);
            channelData = channels.join("\n"); // Keep the formatted data for download

            // Check if the URL contains 'download=1'
            const params = new URLSearchParams(window.location.search);
            if (params.get('download') === '1') {
                // Trigger the download if the parameter is present
                downloadM3U8();
            } else {
                displayChannels(channels); // Otherwise, display channels
            }
        } catch (error) {
            console.error('Error fetching data:', error);
        }
    }

    function parseChannels(data) {
        const lines = data.split('\n');
        const channels = [];
        let channelInfo = [];

        for (const line of lines) {
            if (line.trim() === '') continue; // Ignore empty lines

            // Handle independent lines starting with #☯☯
            if (line.startsWith("#☯☯")) {
                if (channelInfo.length > 0) {
                    channels.push(channelInfo.join("\n")); // Push previous channel's info
                    channelInfo = []; // Reset for a new channel
                }
                channelInfo.push(line.trim()); // Keep independent line
                continue; // Skip further processing of this line
            }

            // Handle KODIPROP for authorization headers
            if (line.startsWith("#KODIPROP:inputstream.adaptive.common_headers")) {
                const tokenMatch = line.match(/authorization=Bearer (.+)$/);
                if (tokenMatch && tokenMatch[1]) {
                    const token = tokenMatch[1];
                    const extHttpLine = `#EXTHTTP:{"Authorization":"Bearer ${token}"}`;
                    channelInfo.push(extHttpLine); // Add formatted token line
                    continue; // Skip the original line
                }
            }

            // Handle KODIPROP for DRM properties
            if (line.startsWith("#KODIPROP:inputstream.adaptive.drm_legacy")) {
                const drmParts = line.split('=')[1];
                const parts = drmParts.split(',');
                const licenseKey = {};
                
                parts.forEach(part => {
                    const [key, value] = part.split(':');
                    // Remove 'org.w3.clearkey|' prefix if it exists
                    const cleanKey = key.replace(/^org\.w3\.clearkey\|/, '');

                    if (cleanKey && value) {
                        licenseKey[cleanKey] = value; // Construct the license key object without prefix
                    }
                });

                channelInfo.push('#KODIPROP:inputstream.adaptive.manifest_type=dash');
                
                // Include the correct license type
                channelInfo.push('#KODIPROP:inputstream.adaptive.license_type=org.w3.clearkey');
                channelInfo.push(`#KODIPROP:inputstream.adaptive.license_key=${JSON.stringify(licenseKey)}`);
                continue; // Skip the original line
            }

            // Handle EXTINF lines and push channel info
            if (line.startsWith("#EXTINF")) {
                if (channelInfo.length > 0) {
                    channels.push(channelInfo.join("\n")); // Push previous channel's info
                    channelInfo = []; // Reset for new channel
                }
            }

            channelInfo.push(line.trim()); // Keep the line
        }

        // Push last channel's information if available
        if (channelInfo.length > 0) {
            channels.push(channelInfo.join("\n"));
        }

        return channels;
    }

    function displayChannels(channels) {
        const channelList = document.getElementById('channel-list');

        channels.forEach(channel => {
            const channelDiv = document.createElement('div');
            channelDiv.className = 'entry';

            const contentElement = document.createElement('pre');
            contentElement.textContent = channel; // Display original formatting
            channelDiv.appendChild(contentElement);
            channelList.appendChild(channelDiv);
        });
    }

    function downloadM3U8() {
        const blob = new Blob([channelData], { type: 'application/vnd.apple.mpegurl' });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = 'channels.m3u8'; // The name of the file to download
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        
        // Clean up the URL object
        URL.revokeObjectURL(url);
    }

    // Fetch TV data and process
    fetchTVData();
</script>

</body>
</html>