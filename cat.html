<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Channel Player with Navigation Mode and Fullscreen</title>
<!-- Video.js CSS -->
<link href="https://vjs.zencdn.net/7.20.3/video-js.css" rel="stylesheet" />
<style>
body {
  display: flex;
  flex-direction: column;
  margin: 0;
  height: 100vh;
  overflow: hidden; /* prevent page scroll */
}

/* Top bar for groups and navigation toggle */
#top-bar {
  display: flex;
  background-color: #f0f0f0;
  padding: 10px;
  position: sticky;
  top: 0;
  z-index: 10;
  overflow-x: auto;
  border-bottom: 1px solid #ccc;
  align-items: center;
}

/* Group buttons style */
.group-btn {
  padding: 8px 12px;
  margin-right: 10px;
  background-color: #fff;
  border: 2px solid #ccc;
  border-radius: 4px;
  cursor: pointer;
  white-space: nowrap;
  font-weight: bold;
  outline: none;
  transition: border-color 0.3s, box-shadow 0.3s;
}

/* Highlight focused/selected group button during navigation */
.group-btn.focused {
  border-color: #007bff;
  box-shadow: 0 0 8px rgba(0,123,255,0.7);
}

/* Navigation toggle button style */
#nav-toggle {
  padding: 8px 12px;
  margin-right: 10px;
  background-color: #ddd;
  border: 1px solid #999;
  border-radius: 4px;
  cursor: pointer;
  font-weight: bold;
  outline: none;
  user-select: none;
}

#nav-toggle.active {
  background-color: #bbb;
}

/* Main content styling */
#main-content {
  display: flex;
  flex: 1;
  height: calc(100vh - 60px);
}

/* Channel list on the left */
#channel-list {
  width: 250px;
  border-right: 1px solid #ccc;
  overflow-y: auto;
  padding: 10px;
  box-sizing: border-box;
  outline: none;
}

/* Channel item styles */
.channel {
  padding: 8px;
  cursor: pointer;
  margin-bottom: 4px;
  border-radius: 4px;
}

.channel:hover {
  background-color: #e0e0e0;
}

/* Focus style for channel list */
.channel.focused {
  background-color: #b0d4f1;
}

/* Style for the video container to occupy full screen when in fullscreen mode */
#player-container {
  flex: 1;
  display: flex;
  justify-content: center;
  align-items: center;
  background: black;
}

/* Make the video element fill the container in fullscreen mode */
#my-video {
  width: 100%;
  height: 100%;
  max-width: 100%;
  max-height: 100%;
}
</style>
</head>
<body>

<!-- Top bar with group buttons and nav toggle -->
<div id="top-bar">
  <div id="nav-toggle">Navigate</div>
  <!-- Group buttons will be appended here dynamically -->
</div>

<!-- Main content: channel list on left, video on right -->
<div id="main-content">
  <div id="channel-list" tabindex="0">
    <h3>Channels</h3>
    <!-- channels will be inserted here -->
  </div>
  <div id="player-container">
    <video id="my-video" class="video-js vjs-default-skin" controls>
      <source src="" type="application/x-mpegURL" />
      Your browser does not support HTML5 video.
    </video>
  </div>
</div>

<!-- Video.js JS -->
<script src="https://vjs.zencdn.net/7.20.3/video.min.js"></script>
<script>
const player = videojs('my-video');
const playlistUrl = 'https://live.catvod.com/tv.m3u';

let channelsByGroup = {};
let channelOrder = [];
let currentChannelUrl = null;

let isNavActive = false; // Whether navigation mode is active
let focusedGroupIndex = 0; // index of the group button in navigation mode
let focusedChannelIndex = -1; // index of focused channel in list

// Fetch and parse playlist
async function fetchPlaylist() {
  try {
    const response = await fetch(playlistUrl);
    const text = await response.text();
    parseM3U(text);
    buildGroupButtons();
  } catch (error) {
    console.error('Failed to fetch playlist:', error);
  }
}

// Parse playlist
function parseM3U(data) {
  channelsByGroup = {};
  channelOrder = [];
  const lines = data.split('\n');
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    if (line.startsWith('#EXTINF')) {
      const groupMatch = line.match(/group-title="([^"]+)"/);
      const nameMatch = line.match(/#EXTINF:-1[^,]*,(.*)$/);
      const channelName = nameMatch ? nameMatch[1].trim() : 'Unknown';
      const groupTitle = groupMatch ? groupMatch[1] : 'Default';

      const urlLine = lines[i + 1] ? lines[i + 1].trim() : '';
      if (urlLine && !urlLine.startsWith('#')) {
        if (!channelsByGroup[groupTitle]) {
          channelsByGroup[groupTitle] = [];
          if (!channelOrder.includes(groupTitle)) {
            channelOrder.push(groupTitle);
          }
        }
        channelsByGroup[groupTitle].push({ name: channelName, url: urlLine });
        i++;
      }
    }
  }
}

// Build group buttons with borders
function buildGroupButtons() {
  const container = document.getElementById('top-bar');
  // Remove existing group buttons (except nav toggle)
  Array.from(container.children).forEach(child => {
    if (child.id !== 'nav-toggle') {
      child.remove();
    }
  });
  // create buttons
  channelOrder.forEach((group, index) => {
    const btn = document.createElement('div');
    btn.className = 'group-btn';
    btn.textContent = group;
    btn.setAttribute('data-index', index);
    btn.onclick = () => {
      selectGroup(group);
    };
    container.appendChild(btn);
  });
  // set initial focus index
  focusedGroupIndex = 0;
  updateButtonFocus();
  // Focus on channel list initially
  document.getElementById('channel-list').focus();
}

// Handle key events for navigation
document.addEventListener('keydown', function(e) {
  if (!isNavActive) return;
  const groupCount = channelOrder.length;
  const currentGroup = channelOrder[focusedGroupIndex];
  const channels = channelsByGroup[currentGroup] || [];
  const channelCount = channels.length;

  if (e.key === 'ArrowLeft') {
    e.preventDefault();
    if (document.activeElement.id === 'nav-toggle') {
      focusedGroupIndex = groupCount - 1;
    } else {
      focusedGroupIndex = (focusedGroupIndex - 1 + groupCount) % groupCount;
    }
    updateButtonFocus();
    selectGroup(channelOrder[focusedGroupIndex]);
  } else if (e.key === 'ArrowRight') {
    e.preventDefault();
    if (document.activeElement.id === 'nav-toggle') {
      focusedGroupIndex = 0;
    } else {
      focusedGroupIndex = (focusedGroupIndex + 1) % groupCount;
    }
    updateButtonFocus();
    selectGroup(channelOrder[focusedGroupIndex]);
  } else if (e.key === 'ArrowUp') {
    e.preventDefault();
    if (channelCount > 0) {
      if (focusedChannelIndex === -1) {
        focusedChannelIndex = 0;
      } else if (focusedChannelIndex > 0) {
        focusedChannelIndex--;
      }
      updateChannelFocus();
      scrollChannelIntoView();
    }
  } else if (e.key === 'ArrowDown') {
    e.preventDefault();
    if (channelCount > 0) {
      if (focusedChannelIndex < channelCount - 1) {
        focusedChannelIndex++;
        updateChannelFocus();
        scrollChannelIntoView();
      }
    }
  } else if (e.key === 'Enter' || e.key === 'Accept') {
    e.preventDefault();
    activateItem();
  } else if (e.key === 'Escape') {
    e.preventDefault();
    if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) {
      exitFullscreen();
    }
  }
});

// Scroll the focused channel into view
function scrollChannelIntoView() {
  const container = document.getElementById('channel-list');
  const items = container.querySelectorAll('.channel');
  if (focusedChannelIndex >= 0 && items[focusedChannelIndex]) {
    const item = items[focusedChannelIndex];
    item.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
  }
}

// Update visual focus for group buttons
function updateButtonFocus() {
  document.querySelectorAll('.group-btn').forEach((btn, index) => {
    if (index === focusedGroupIndex && isNavActive) {
      btn.classList.add('focused');
    } else {
      btn.classList.remove('focused');
    }
  });
}

// Update focused channel item
function updateChannelFocus() {
  document.querySelectorAll('.channel').forEach((item, index) => {
    if (index === focusedChannelIndex && isNavActive) {
      item.classList.add('focused');
    } else {
      item.classList.remove('focused');
    }
  });
}

// When Enter or OK is pressed, activate the focused item
function activateItem() {
  const currentGroup = channelOrder[focusedGroupIndex];
  const channels = channelsByGroup[currentGroup] || [];
  if (focusedChannelIndex >= 0 && channels.length > 0) {
    const channel = channels[focusedChannelIndex];
    loadChannel(channel.url);
  } else {
    // If focus is on group, select the group
    selectGroup(currentGroup);
  }
}

// Toggle navigation mode
const navToggle = document.getElementById('nav-toggle');
navToggle.onclick = () => {
  isNavActive = !isNavActive;
  navToggle.classList.toggle('active', isNavActive);
  if (isNavActive) {
    document.getElementById('channel-list').focus();
    updateButtonFocus();
    updateChannelFocus();
  } else {
    document.querySelectorAll('.group-btn').forEach(b => b.classList.remove('focused'));
    document.querySelectorAll('.channel').forEach(c => c.classList.remove('focused'));
  }
};

// Build channel list for a group
function selectGroup(group) {
  focusedGroupIndex = channelOrder.indexOf(group);
  focusedChannelIndex = 0;
  updateButtonFocus();
  const container = document.getElementById('channel-list');
  container.innerHTML = '<h3>Channels in ' + group + '</h3>';
  if (channelsByGroup[group]) {
    channelsByGroup[group].forEach((channel, index) => {
      const div = document.createElement('div');
      div.className = 'channel';
      div.textContent = channel.name;
      div.setAttribute('data-index', index);
      div.onclick = () => {
        loadChannel(channel.url);
        enterFullscreen(); // Enter fullscreen on channel load
      };
      container.appendChild(div);
    });
  }
  focusedChannelIndex = channelsByGroup[group] ? 0 : -1;
  updateChannelFocus();
}

// Load channel
function loadChannel(url) {
  if (currentChannelUrl !== url) {
    currentChannelUrl = url;
    player.src({ type: 'application/x-mpegURL', src: url });
    player.load();
    player.play();
    enterFullscreen(); // Enter fullscreen when a channel is selected
  }
}

// Enter fullscreen mode
function enterFullscreen() {
  const videoContainer = document.getElementById('player-container');
  if (videoContainer.requestFullscreen) {
    videoContainer.requestFullscreen();
  } else if (videoContainer.mozRequestFullScreen) {
    videoContainer.mozRequestFullScreen();
  } else if (videoContainer.webkitRequestFullscreen) {
    videoContainer.webkitRequestFullscreen();
  } else if (videoContainer.msRequestFullscreen) {
    videoContainer.msRequestFullscreen();
  }
}

// Exit fullscreen mode
function exitFullscreen() {
  if (document.exitFullscreen) {
    document.exitFullscreen();
  } else if (document.mozCancelFullScreen) {
    document.mozCancelFullScreen();
  } else if (document.webkitExitFullscreen) {
    document.webkitExitFullscreen();
  } else if (document.msExitFullscreen) {
    document.msExitFullscreen();
  }
}

// Optional: Resize the video element to fill the screen when in fullscreen
// (Already handled by CSS, but ensure container fills screen in fullscreen)
document.addEventListener('fullscreenchange', () => {
  if (document.fullscreenElement) {
    // When entering fullscreen, ensure container fills screen
    document.getElementById('player-container').style.width = '100%';
    document.getElementById('player-container').style.height = '100%';
  } else {
    // When leaving fullscreen, revert styles if needed
    document.getElementById('player-container').style.width = '';
    document.getElementById('player-container').style.height = '';
  }
});

// Listen for ESC key to exit fullscreen
document.addEventListener('keydown', function(e) {
  if (e.key === 'Escape') {
    e.preventDefault();
    if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) {
      exitFullscreen();
    }
  }
});

// Initialize
fetchPlaylist();
</script>
</body>
</html>