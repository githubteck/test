name: Fetch and Upload M3U8 File

on:
  schedule:
    - cron: '0 * * * *'  # Runs every hour (adjust as needed)
  workflow_dispatch:  # Allows manual trigger of the workflow

jobs:
  upload_m3u8:
    runs-on: ubuntu-latest  # Use the latest Ubuntu runner

    steps:
    - name: Checkout repository
      uses: actions/checkout@v2  # Checkout the repository so we can upload the file

    - name: Set up Python
      uses: actions/setup-python@v2
      with:
        python-version: '3.x'  # Use Python 3.x

    - name: Install dependencies
      run: |
        pip install requests  # Install the required dependencies, such as the `requests` library

    - name: Fetch, Parse, and Upload M3U8
      run: |
        python3 <<EOF
        # Python script content here
        import requests
        import base64

        # URL of the external data source (same as the one used in your HTML)
        data_url = 'https://raw.githubusercontent.com/aseanic/aseanic.github.io/refs/heads/main/tv'

        # GitHub API details
        repo_owner = 'githubteck'  # Replace with your GitHub username
        repo_name = 'test'  # Replace with your GitHub repository name
        file_path = '123.m3u8'  # Path in the GitHub repository where the file will be uploaded
        access_token = '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'  # Your GitHub personal access token

        def fetch_tv_data():
            """Fetch the raw TV data from the URL."""
            response = requests.get(data_url)
            if response.status_code == 200:
                return response.text
            else:
                print(f"Failed to fetch the raw data: {response.status_code}")
                return None

        def parse_channels(data):
            """Parse the TV data and convert it to M3U8 format."""
            lines = data.split('\n')
            channels = []
            channel_info = []

            for line in lines:
                if line.strip() == '':
                    continue  # Ignore empty lines
                
                # Handle the start of a new channel (identified by "#☯☯")
                if line.startswith("#☯☯"):
                    if channel_info:
                        channels.append("\n".join(channel_info))  # Save the previous channel data
                    channel_info = [line.strip()]  # Start a new channel
                    continue
                
                # Handle input stream headers (authentication or DRM)
                if line.startswith("#KODIPROP:inputstream.adaptive.common_headers"):
                    token_match = line.match(r'authorization=Bearer (.+)$')
                    if token_match and token_match[1]:
                        token = token_match[1]
                        ext_http_line = f'#EXTHTTP:{{"Authorization":"Bearer {token}"}}'
                        channel_info.append(ext_http_line)
                    continue

                if line.startswith("#KODIPROP:inputstream.adaptive.drm_legacy"):
                    drm_parts = line.split('=')[1]  # Get everything after '='
                    parts = drm_parts.split(',')

                    if 'org.w3.clearkey' in line:
                        license_key = {}
                        for part in parts:
                            key, value = part.split(':')
                            clean_key = key.replace('org.w3.clearkey|', '')
                            license_key[clean_key] = value
                        channel_info.append('#KODIPROP:inputstream.adaptive.manifest_type=dash')
                        channel_info.append('#KODIPROP:inputstream.adaptive.license_type=org.w3.clearkey')
                        channel_info.append(f'#KODIPROP:inputstream.adaptive.license_key={license_key}')
                    elif 'com.widevine.alpha' in line:
                        widevine_license_url = parts[1].strip()  # Capture everything after '|'
                        channel_info.append('#KODIPROP:inputstream.adaptive.license_type=com.widevine.alpha')
                        channel_info.append(f'#KODIPROP:inputstream.adaptive.license_key={widevine_license_url}')
                    continue

                # Handle the "#EXTINF" line that provides the channel metadata
                if line.startswith("#EXTINF"):
                    if channel_info:
                        channels.append("\n".join(channel_info))  # Save the previous channel
                    channel_info = [line.strip()]  # Start a new channel
                    continue
                
                channel_info.append(line.strip())  # Add regular data line (like channel URL)

            if channel_info:  # Append any remaining channel info
                channels.append("\n".join(channel_info))
            
            return channels

        def upload_to_github(content):
            """Upload the M3U8 data to GitHub."""
            file_content = base64.b64encode(content.encode()).decode()

            api_url = f'https://api.github.com/repos/{repo_owner}/{repo_name}/contents/{file_path}'
            data = {
                'message': 'Upload channels.m3u8 file',  # Commit message
                'content': file_content  # Base64 encoded content
            }

            headers = {
                'Authorization': f'token {access_token}'
            }

            # Send the request to upload the file
            upload_response = requests.put(api_url, json=data, headers=headers)

            if upload_response.status_code == 201:
                print("File uploaded successfully!")
            else:
                print(f"Failed to upload file: {upload_response.content}")

        def main():
            # Step 1: Fetch the TV data from the external source
            raw_data = fetch_tv_data()
            if raw_data:
                # Step 2: Parse the raw data into channels
                channels = parse_channels(raw_data)

                # Step 3: Prepare the M3U8 content by joining channels
                m3u8_content = "\n".join(channels)

                # Step 4: Upload the M3U8 content to GitHub
                upload_to_github(m3u8_content)

        if __name__ == "__main__":
            main()
        EOF
