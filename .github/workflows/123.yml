name: Fetch and Upload M3U8 File

on:
  schedule:
    - cron: '0 * * * *'  # Runs every hour (adjust as needed)
  workflow_dispatch:  # Allows manual trigger of the workflow

jobs:
  upload_m3u8:
    runs-on: ubuntu-latest  # Use the latest Ubuntu runner

    steps:
    - name: Checkout repository
      uses: actions/checkout@v2  # Checkout the repository so we can upload the file

    - name: Set up Python
      uses: actions/setup-python@v2
      with:
        python-version: '3.x'  # Use Python 3.x

    - name: Install dependencies
      run: |
        pip install requests  # Install the required dependencies, such as the `requests` library

    - name: Fetch, Parse, and Upload M3U8
      run: |
        python3 <<EOF
        # Python script content here
import requests
import base64
import re  # Import the re module for regular expressions

# URL of the external data source (same as the one used in your HTML)
data_url = 'https://raw.githubusercontent.com/aseanic/aseanic.github.io/refs/heads/main/tv'

# GitHub API details
repo_owner = 'githubteck'  # Replace with your GitHub username
repo_name = 'test'  # Replace with your GitHub repository name
file_path = '123.m3u8'  # Path in the GitHub repository where the file will be uploaded
access_token = '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'  # Your GitHub personal access token

def fetch_tv_data():
    """Fetch the raw TV data from the URL."""
    response = requests.get(data_url)
    if response.status_code == 200:
        return response.text
    else:
        print(f"Failed to fetch the raw data: {response.status_code}")
        return None

def parse_channels(data):
    """Parse the TV data and convert it to M3U8 format."""
    lines = data.split('\n')
    channels = []
    channel_info = []

    for line in lines:
        if line.strip() == '':
            continue  # Ignore empty lines
        
        # Handle the start of a new channel (identified by "#☯☯")
        if line.startswith("#☯☯"):
            if channel_info:
                channels.append("\n".join(channel_info))  # Save the previous channel data
            channel_info = [line.strip()]  # Start a new channel
            continue
        
        # Handle input stream headers (authentication or DRM)
        if line.startswith("#KODIPROP:inputstream.adaptive.common_headers"):
            # Use re.search() instead of match()
            token_match = re.search(r'authorization=Bearer (.+)', line)  # Corrected line
            if token_match and token_match.group(1):
                token = token_match.group(1)
                ext_http_line = f'#EXTHTTP:{{"Authorization":"Bearer {token}"}}'
                channel_info.append(ext_http_line)
            continue

    # Append the final channel info if any
    if channel_info:
        channels.append("\n".join(channel_info))

    return channels

def upload_to_github(content):
    """Upload the M3U8 data to GitHub."""
    file_content = base64.b64encode(content.encode()).decode()

    api_url = f'https://api.github.com/repos/{repo_owner}/{repo_name}/contents/{file_path}'
    data = {
        'message': 'Upload channels.m3u8 file',  # Commit message
        'content': file_content  # Base64 encoded content
    }

    headers = {
        'Authorization': f'token {access_token}'
    }

    # Send the request to upload the file
    upload_response = requests.put(api_url, json=data, headers=headers)

    if upload_response.status_code == 201:
        print("File uploaded successfully!")
    else:
        print(f"Failed to upload file: {upload_response.content}")

def main():
    # Step 1: Fetch the TV data from the external source
    raw_data = fetch_tv_data()
    if raw_data:
        # Step 2: Parse the raw data into channels
        channels = parse_channels(raw_data)

        # Step 3: Prepare the M3U8 content by joining channels
        m3u8_content = "\n".join(channels)

        # Step 4: Upload the M3U8 content to GitHub
        upload_to_github(m3u8_content)

if __name__ == "__main__":
    main()
        EOF
